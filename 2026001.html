<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>图6：正五边形围成空心圆圈（同向转弯拼接）</title>
  <style>
    body{font-family:system-ui,-apple-system,"Segoe UI",Arial;margin:12px;}
    #wrap{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;}
    canvas{border:1px solid #bbb;border-radius:8px;background:#fff;}
    .panel{min-width:320px;max-width:520px;}
    .row{margin:8px 0;}
    button{margin-right:8px;padding:8px 12px;border-radius:8px;border:1px solid #999;background:#f7f7f7;cursor:pointer;}
    button:active{transform:translateY(1px);}
    .kv{line-height:1.7;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;}
    label{margin-right:12px;}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="cv" width="900" height="540"></canvas>

  <div class="panel">
    <div class="row">
      <button id="btnAdd">添加一个</button>
      <button id="btnUndo">撤销</button>
      <button id="btnReset">重置</button>
      <button id="btnAuto">自动加到闭合</button>
    </div>

    <div class="row">
      <label><input type="radio" name="turn" value="left" checked> 一直向左转（更像图6）</label>
      <label><input type="radio" name="turn" value="right"> 一直向右转</label>
    </div>

    <div class="row kv">
      <div>已放个数：<span class="mono" id="n">0</span></div>
      <div>理论每次转角：<span class="mono">72</span>°（正五边形外角）</div>
      <div>累计转角（理论）：<span class="mono" id="turnDeg">0</span>°</div>
      <div>离 360° 还差：<span class="mono" id="gapDeg">360</span>°</div>
      <div>闭合判定阈值：<span class="mono" id="epsShow"></span></div>
    </div>

    <div class="row">
      <div>闭合误差阈值(px)：<span class="mono" id="epsVal">2.0</span></div>
      <input id="eps" type="range" min="0.5" max="10" step="0.5" value="2.0" style="width:260px;">
    </div>

    <div class="row" style="color:#333;font-size:14px;line-height:1.6;">
      关键点：图6那种“围成圈”不是左右来回拼，而是每次都在同一侧继续拼，
      也就是链条一直同向转弯，所以会自然围出一个“中间空心”的区域，最终闭合。
    </div>
  </div>
</div>

<script>
/* 向量工具 */
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function dot(a,b){return a.x*b.x+a.y*b.y;}
function len(a){return Math.hypot(a.x,a.y);}
function rot(p,th){const c=Math.cos(th),s=Math.sin(th);return {x:p.x*c-p.y*s,y:p.x*s+p.y*c};}
function angleOf(v){return Math.atan2(v.y,v.x);}
function perpLeft(v){return {x:-v.y,y:v.x};} // 指向“左侧”的法向
function dist(a,b){return len(sub(a,b));}

function makePentagonTemplate(R){
  const pts=[];
  const start=-Math.PI/2;
  for(let i=0;i<5;i++){
    const th=start+i*(2*Math.PI/5);
    pts.push({x:R*Math.cos(th),y:R*Math.sin(th)});
  }
  return pts;
}
function centroid(pts){
  let x=0,y=0;
  for(const p of pts){x+=p.x;y+=p.y;}
  return {x:x/pts.length,y:y/pts.length};
}
function edge(pts,i){
  return {a:pts[i], b:pts[(i+1)%5]};
}

/* 把模板五边形贴到目标边A->B，并强制在边的“左侧/右侧” */
function placeByEdge(templatePts, A, B, side /* +1左 -1右 */){
  const p0=templatePts[0], p1=templatePts[1];
  const vT=sub(p1,p0);
  const vW=sub(B,A);

  const th=angleOf(vW)-angleOf(vT);
  const p0r=rot(p0,th);
  const trans=sub(A,p0r);
  let placed=templatePts.map(p=>add(rot(p,th),trans));

  // 检查中心在A->B哪侧
  const c=centroid(placed);
  const n=perpLeft(vW);
  const sideVal=dot(sub(c,A), n); // >0 左侧

  const wantLeft = (side===+1);
  const isLeft = (sideVal>=0);
  if((wantLeft && isLeft) || (!wantLeft && !isLeft)) return placed;

  // 不在想要侧，则把模板边贴到 B->A（等效翻到另一侧）
  const vW2=sub(A,B);
  const th2=angleOf(vW2)-angleOf(vT);
  const p0r2=rot(p0,th2);
  const trans2=sub(B,p0r2);
  placed=templatePts.map(p=>add(rot(p,th2),trans2));
  return placed;
}

/* 拼接数据结构：每个poly保存下一次要用来继续拼的“出边索引” */
const cv=document.getElementById("cv");
const ctx=cv.getContext("2d");

const R=72;
const template=makePentagonTemplate(R);
let polys=[];

function getTurnSide(){
  const v=document.querySelector('input[name="turn"]:checked').value;
  return (v==="left") ? +1 : -1;
}

function reset(){
  polys=[];
  const center={x:cv.width*0.45,y:cv.height*0.55};
  const pts=template.map(p=>add(p,center));
  // 初始“出边”取 0（你也可以改成别的边，视觉差异不影响结论）
  polys.push({pts, outEdge:0});
  draw();
  updateInfo();
}

function addOne(){
  const side=getTurnSide(); // +1 左侧拼（同向转弯），-1 右侧拼
  const last=polys[polys.length-1];
  const e=edge(last.pts,last.outEdge);
  const A=e.a, B=e.b;

  // 关键修正：不再取“相反侧”，而是固定取同一侧（一直左/一直右）
  const newPts=placeByEdge(template, A, B, side);

  // 继续沿着新五边形的相邻边往前拼：edge1（从模板意义上）
  polys.push({pts:newPts, outEdge:1});

  draw();
  updateInfo();
}

function undo(){
  if(polys.length<=1) return;
  polys.pop();
  draw();
  updateInfo();
}

function autoClose(){
  const eps=parseFloat(document.getElementById("eps").value);
  let guard=80;
  while(guard-- > 0){
    const pStart=polys[0].pts[0];
    const pEnd=polys[polys.length-1].pts[0];
    if(polys.length>1 && dist(pStart,pEnd)<=eps) break;
    addOne();
  }
  updateInfo();
}

/* 信息（理论角度 + 几何闭合） */
function updateInfo(){
  const n=polys.length;
  document.getElementById("n").textContent=n;

  const turnPer=72;
  const turn=(n-1)*turnPer;
  const turnMod=((turn%360)+360)%360;
  const gap=(360-turnMod)%360;
  document.getElementById("turnDeg").textContent=turnMod.toFixed(0);
  document.getElementById("gapDeg").textContent=gap.toFixed(0);

  const eps=parseFloat(document.getElementById("eps").value);
  document.getElementById("epsVal").textContent=eps.toFixed(1);
  document.getElementById("epsShow").textContent=eps.toFixed(1)+" px";

  const pStart=polys[0].pts[0];
  const pEnd=polys[polys.length-1].pts[0];
  const d=dist(pStart,pEnd);

  const msg = (n>1 && d<=eps)
    ? `✅ 近似闭合：当前 ${n} 个五边形（同向转弯），形成“中间空心”的环。`
    : `未闭合：起点-终点距离约 ${d.toFixed(1)} px`;

  draw(msg);
}

/* 绘图 */
function draw(message=""){
  ctx.clearRect(0,0,cv.width,cv.height);

  // 网格
  ctx.save();
  ctx.globalAlpha=0.08;
  ctx.strokeStyle="#000";
  for(let x=0;x<cv.width;x+=40){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,cv.height);ctx.stroke();}
  for(let y=0;y<cv.height;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  ctx.restore();

  // 五边形
  polys.forEach((poly,idx)=>{
    const pts=poly.pts;
    ctx.lineWidth = (idx===polys.length-1) ? 3 : 2;
    ctx.strokeStyle = (idx===polys.length-1) ? "#d33" : "#333";
    ctx.fillStyle="rgba(0,0,0,0.03)";
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    for(let i=1;i<5;i++) ctx.lineTo(pts[i].x,pts[i].y);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // 标记“出边”（下一次拼接用的边）
    const e=edge(pts,poly.outEdge);
    ctx.lineWidth=5;
    ctx.strokeStyle="#1a73e8";
    ctx.beginPath(); ctx.moveTo(e.a.x,e.a.y); ctx.lineTo(e.b.x,e.b.y); ctx.stroke();

    // 序号
    const c=centroid(pts);
    ctx.fillStyle="#111";
    ctx.font="14px ui-monospace,Menlo,Consolas,monospace";
    ctx.fillText(String(idx+1), c.x-4, c.y+5);
  });

  // 起点/终点
  const p0=polys[0].pts[0];
  const plast=polys[polys.length-1].pts[0];

  ctx.fillStyle="#0b8043";
  ctx.beginPath(); ctx.arc(p0.x,p0.y,6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#111"; ctx.font="14px system-ui";
  ctx.fillText("起点", p0.x+10, p0.y+5);

  ctx.fillStyle="#d33";
  ctx.beginPath(); ctx.arc(plast.x,plast.y,6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#111";
  ctx.fillText("终点", plast.x+10, plast.y+5);

  // 标题与提示
  ctx.fillStyle="#111";
  ctx.font="16px system-ui";
  ctx.fillText("图6拼法：每次固定在同一侧拼接（同向转弯）→ 外圈围出中间空心 → 最终闭合", 16, 26);

  if(message){
    ctx.fillStyle="#111";
    ctx.font="15px system-ui";
    ctx.fillText(message, 16, 50);
  }

  ctx.fillStyle="#444";
  ctx.font="14px system-ui";
  ctx.fillText("观察：每添一个五边形，链条就再“转”72°；转满360°就闭合。", 16, cv.height-16);
}

/* 事件 */
document.getElementById("btnAdd").onclick=addOne;
document.getElementById("btnUndo").onclick=undo;
document.getElementById("btnReset").onclick=reset;
document.getElementById("btnAuto").onclick=autoClose;
document.getElementById("eps").oninput=updateInfo;
document.querySelectorAll('input[name="turn"]').forEach(r=>r.onchange=()=>{draw();updateInfo();});

reset();
</script>
</body>
</html>